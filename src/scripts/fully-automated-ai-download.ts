import { ImprovedTurnitinScraperService } from '../services/improved-turnitin-scraper.service';
import { Page, ElementHandle } from 'puppeteer';
import * as readline from 'readline';
import fs from 'fs';
import path from 'path';
import os from 'os';

const EXACT_JSON_DATA = {
    workTitle: "LA LECTURA.docx",
    aiButtonCSS: "tii-aiw-button.hydrated", // Este es para ir a la p√°gina del reporte de IA
    expectedFinalUrl: "https://awo-usw2.integrity.turnitin.com/trn:oid:::1:3272334500"
};

// XPath para el bot√≥n de descarga DENTRO del popover en la p√°gina del reporte de IA
const AI_REPORT_PAGE_DOWNLOAD_BUTTON_SELECTOR = '//*[@id="download-popover"]/ul/li/button';
const IS_XPATH_SELECTOR = true; // Este es un XPath

// Selector para el bot√≥n que ABRIR√çA el popover de descarga (el √≠cono de descarga principal).
const POPOVER_OPENER_SELECTOR = "//tii-sws-header-btn[.//tdl-icon[@icon-name='download']]//button | //tii-sws-header-btn[.//tdl-icon[@icon-name='download']] | //tii-sws-download-btn-mfe//button | //tii-sws-download-btn-mfe";
const IS_POPOVER_OPENER_XPATH = true; // Este es un XPath

async function fullyAutomatedAIDownload() {
    const scraper = new ImprovedTurnitinScraperService(true);
    const mainRl = readline.createInterface({ input: process.stdin, output: process.stdout });
    const mainAskQuestion = (question: string): Promise<string> => new Promise((resolve) => mainRl.question(question, resolve));

    let currentPage: Page | null = null;
    const projectDownloadPath = scraper.getDownloadPath(); // Definir aqu√≠ para usar en screenshots de error

    try {
        console.log('üöÄ INICIANDO DESCARGA TOTALMENTE AUTOMATIZADA DE REPORTE DE IA');
        await scraper.initializeBrowser();
        currentPage = await scraper.createNewPage();
        
        console.log(`üìÅ Configurando descarga en: ${projectDownloadPath}`);
        try {
            const client = await currentPage.target().createCDPSession();
            await client.send('Page.setDownloadBehavior', {
                behavior: 'allow',
                downloadPath: projectDownloadPath
            });
            console.log('‚úÖ Carpeta de descarga configurada en el navegador');
        } catch (cdpError: any) {
            console.warn(`‚ö†Ô∏è No se pudo configurar la carpeta de descarga v√≠a CDP: ${cdpError.message}.`);
        }

        const aiReportPageInstance = await navigateToAIReportPage(scraper, currentPage, mainAskQuestion);

        if (!aiReportPageInstance) {
            console.log('‚ùå No se pudo obtener la instancia de la p√°gina del reporte de IA.');
            return;
        }
        currentPage = aiReportPageInstance;
        console.log(`‚úÖ Navegaci√≥n exitosa a la p√°gina del reporte de IA: ${currentPage.url()}`);
        
        console.log('‚è≥ Esperando carga completa de la p√°gina del reporte de IA (30 segundos)...');
        await currentPage.waitForTimeout(30000); // Aumentar espera inicial considerablemente

        let downloadActionSuccessful = false;
        let attempt = 1;
        const maxAttempts = 2; // Intentar una vez, luego refrescar e intentar de nuevo

        while (attempt <= maxAttempts && !downloadActionSuccessful) {
            console.log(`\nüîé Intento ${attempt} de ${maxAttempts} para encontrar y hacer clic en el bot√≥n de descarga.`);
            
            let popoverOpener: ElementHandle<Element> | null = null;
            if (POPOVER_OPENER_SELECTOR) { 
                try {
                    console.log(`ü§ñ Buscando bot√≥n para abrir popover con selector: ${POPOVER_OPENER_SELECTOR}`);
                    if (IS_POPOVER_OPENER_XPATH) {
                        // Esperar a que alguno de los elementos del XPath sea visible
                        await currentPage.waitForXPath(POPOVER_OPENER_SELECTOR, { timeout: 20000, visible: true }); // Aumentado timeout
                        const openers = await currentPage.$x(POPOVER_OPENER_SELECTOR);
                        if (openers.length > 0) {
                            popoverOpener = openers[0] as ElementHandle<Element>; // Tomar el primero que coincida
                            console.log(`‚úÖ Bot√≥n para abrir popover encontrado con XPath (se encontr√≥ ${openers.length} coincidencia(s)).`);
                        } else {
                             console.log('‚ö†Ô∏è No se encontr√≥ el bot√≥n para abrir el popover con el XPath proporcionado (openers.length es 0).');
                        }
                    } else {
                        await currentPage.waitForSelector(POPOVER_OPENER_SELECTOR, { timeout: 20000, visible: true }); // Aumentado timeout
                        popoverOpener = await currentPage.$(POPOVER_OPENER_SELECTOR);
                         if (popoverOpener) {
                            console.log('‚úÖ Bot√≥n para abrir popover encontrado con CSS selector.');
                        } else {
                            console.log('‚ö†Ô∏è No se encontr√≥ el bot√≥n para abrir el popover con el CSS selector proporcionado.');
                        }
                    }

                    if (popoverOpener) {
                        console.log('‚úÖ Bot√≥n para abrir popover listo. Haciendo clic...');
                        await currentPage.evaluate(el => (el as HTMLElement).click(), popoverOpener);
                        console.log('üñ±Ô∏è Clic en abridor de popover realizado. Esperando que aparezca el popover y el bot√≥n final (10 segundos)...');
                        try {
                            // Esperar a que el bot√≥n de descarga DENTRO del popover sea visible
                            await currentPage.waitForXPath(AI_REPORT_PAGE_DOWNLOAD_BUTTON_SELECTOR, { visible: true, timeout: 10000 });
                            console.log('‚úÖ Popover parece estar abierto y el bot√≥n de descarga final est√° visible.');
                        } catch (popoverWaitError: any) {
                            console.warn(`üî∂ Popover o bot√≥n de descarga final no se hizo visible despu√©s del clic en el abridor: ${popoverWaitError.message}`);
                            const popoverErrorPath = path.join(projectDownloadPath, `error_popover_not_visible_attempt_${attempt}_${Date.now()}.png`);
                            if (currentPage) await currentPage.screenshot({ path: popoverErrorPath });
                            console.log(`üì∏ Screenshot de error de popover guardado en: ${popoverErrorPath}`);
                        }
                    } else {
                        // Mensaje ya se muestra arriba si no se encuentra
                    }
                } catch (e: any) {
                    console.log(`üî∂ Error al intentar encontrar/abrir popover: ${e.message}`);
                    const openerErrorPath = path.join(projectDownloadPath, `error_popover_opener_attempt_${attempt}_${Date.now()}.png`);
                    if (currentPage) await currentPage.screenshot({ path: openerErrorPath });
                    console.log(`üì∏ Screenshot de error de abridor de popover guardado en: ${openerErrorPath}`);
                }
            } else {
                 // Esta rama ahora se ejecutar√≠a si POPOVER_OPENER_SELECTOR fuera una cadena vac√≠a.
                 console.log("‚ÑπÔ∏è No se ha configurado un selector para abrir popover (POPOVER_OPENER_SELECTOR est√° vac√≠o), se buscar√° el bot√≥n de descarga directamente.");
            }

            // Intentar hacer clic en el bot√≥n de descarga final
            let downloadButton: ElementHandle<Element> | null = null;
            console.log(`ü§ñ Buscando bot√≥n de descarga final con XPath: ${AI_REPORT_PAGE_DOWNLOAD_BUTTON_SELECTOR}`);
            try {
                await currentPage.waitForXPath(AI_REPORT_PAGE_DOWNLOAD_BUTTON_SELECTOR, { visible: true, timeout: 20000 }); // Aumentado timeout
                const elements = await currentPage.$x(AI_REPORT_PAGE_DOWNLOAD_BUTTON_SELECTOR);
                if (elements.length > 0) {
                    downloadButton = elements[0] as ElementHandle<Element>;
                }
            } catch (e: any) {
                console.log(`‚ùå Error esperando el XPath del bot√≥n de descarga final: ${e.message}`);
            }

            if (downloadButton) {
                console.log('‚úÖ Bot√≥n de descarga final encontrado y visible. Haciendo clic...');
                try {
                    await currentPage.evaluate(el => (el as HTMLElement).click(), downloadButton);
                    console.log('üñ±Ô∏è Clic realizado en el bot√≥n de descarga final. Esperando inicio de descarga (20 segundos)...');
                    await currentPage.waitForTimeout(20000);
                    downloadActionSuccessful = true; 
                } catch (clickError: any) {
                    console.error(`‚ùå Error al hacer clic en el bot√≥n de descarga final: ${clickError.message}`);
                    const clickErrorScreenshotPath = path.join(projectDownloadPath, `error_click_download_btn_attempt_${attempt}_${Date.now()}.png`);
                    if (currentPage) await currentPage.screenshot({ path: clickErrorScreenshotPath });
                    console.log(`üì∏ Screenshot de error de clic guardado en: ${clickErrorScreenshotPath}`);
                }
            } else {
                console.log(`‚ùå No se encontr√≥ el bot√≥n de descarga final en el intento ${attempt}.`);
                const notFoundScreenshotPath = path.join(projectDownloadPath, `error_btn_not_found_attempt_${attempt}_${Date.now()}.png`);
                if (currentPage) await currentPage.screenshot({ path: notFoundScreenshotPath });
                console.log(`üì∏ Screenshot de "no encontrado" guardado en: ${notFoundScreenshotPath}`);
            }
            
            if (!downloadActionSuccessful && attempt < maxAttempts) {
                console.log('üîÑ Refrescando p√°gina y esperando antes del siguiente intento...');
                try {
                    if (currentPage) {
                        await currentPage.reload({ waitUntil: ["networkidle0", "domcontentloaded"], timeout: 60000 }); // Aumentado timeout
                        console.log('‚è≥ Esperando despu√©s del refresco (30 segundos)...');
                        await currentPage.waitForTimeout(30000);
                    } else {
                        console.error("‚ùå No se puede refrescar, la p√°gina actual es nula.");
                        break; // Salir del bucle si no hay p√°gina
                    }
                } catch (reloadError: any) {
                    console.error(`‚ùå Error durante el refresco de p√°gina: ${reloadError.message}`);
                    const reloadErrorPath = path.join(projectDownloadPath, `error_reload_attempt_${attempt}_${Date.now()}.png`);
                    if (currentPage) await currentPage.screenshot({ path: reloadErrorPath });
                    console.log(`üì∏ Screenshot de error de refresco guardado en: ${reloadErrorPath}`);
                    break; 
                }
            }
            attempt++;
        }

        if (!downloadActionSuccessful) {
            console.log('‚ùå‚ùå No se pudo hacer clic en el bot√≥n de descarga despu√©s de todos los intentos.');
        }

        await detectAndConfirmDownload(projectDownloadPath);

    } catch (error: any) {
        console.error(`‚ùå ERROR FATAL: ${error.message}`);
        if (currentPage) {
            const fatalErrorScreenshotPath = path.join(projectDownloadPath, `fatal_error_screenshot_${Date.now()}.png`);
            try {
                await currentPage.screenshot({ path: fatalErrorScreenshotPath });
                console.log(`üì∏ Screenshot de error fatal guardado en: ${fatalErrorScreenshotPath}`);
            } catch (screenshotError: any) { 
                console.error(`No se pudo tomar screenshot del error fatal: ${(screenshotError as Error).message}`);
            }
        }
        if (error.stack) console.error(error.stack);
    } finally {
        console.log('\nPresiona ENTER para cerrar...');
        await mainAskQuestion(''); 
        if (scraper) await scraper.closeBrowser();
        mainRl.close(); 
    }
}

// Added askLoginPrompt as a parameter to avoid redeclaring readline interface
async function navigateToAIReportPage(
    scraper: ImprovedTurnitinScraperService, 
    page: Page,
    // mainAskQuestion is not used in this version as rl is local
    _mainAskQuestion?: (question: string) => Promise<string> // Parameter can be optional or removed if not used
): Promise<Page | null> {
    // rl and askQuestion are defined locally within this function
    const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
    const askQuestion = (question: string): Promise<string> => new Promise((resolve) => {
        // Removed: if (rl.closed) { ... }
        // We assume rl is active when askQuestion is called within this function's scope.
        // rl.question will handle its own state or error if called inappropriately,
        // but the design here is that it's called before rl.close().
        try {
            rl.question(question, resolve);
        } catch (e: any) {
            console.warn(`Readline question error: ${e.message}. Resolving with empty string.`);
            resolve(''); // Gracefully handle if rl.question throws (e.g., if rl was closed unexpectedly)
        }
    });
    
    try {
        await scraper.navigateToTurnitinInbox(page);
        if (page.url().includes('login')) {
            console.log('üîê Inicia sesi√≥n manualmente y presiona ENTER...');
            await askQuestion(''); 
            await scraper.navigateToTurnitinInbox(page);
        }
        console.log(`üéØ Buscando trabajo: "${EXACT_JSON_DATA.workTitle}"`);
        if (!await scraper.findAndClickOnSubmission(page, EXACT_JSON_DATA.workTitle)) {
            throw new Error('No se pudo abrir el trabajo');
        }
        
        const browser = page.browser();
        let targetPage: Page | null = null;

        const newPagePromise = new Promise<Page | null>(resolve => browser.once('targetcreated', async target => { 
            if (target.type() === 'page') {
                const newPageCandidate = await target.page();
                resolve(newPageCandidate); 
            } else {
                resolve(null);
            }
        }));

        let pages = await browser.pages();
        let cartaPage: Page | undefined = pages.find(p => p.url().includes('ev.turnitin.com/app/carta'));
        
        if (!cartaPage) { 
            await page.waitForTimeout(3000);
            pages = await browser.pages();
            cartaPage = pages.find(p => p.url().includes('ev.turnitin.com/app/carta'));
        }

        if (!cartaPage) {
            throw new Error('P√°gina de Carta no encontrada despu√©s de m√∫ltiples intentos.');
        }
        
        console.log(`‚úÖ P√°gina de Carta encontrada/confirmada: ${cartaPage.url()}`);
        
        await cartaPage.bringToFront();
        await cartaPage.waitForTimeout(5000); 
        
        console.log('ü§ñ Haciendo clic en bot√≥n de IA...');
        
        const aiButton = await cartaPage.$(EXACT_JSON_DATA.aiButtonCSS);
        if (!aiButton) {
            throw new Error('No se encontr√≥ el bot√≥n de IA en la p√°gina de Carta');
        }

        await aiButton.click();
        console.log('‚úÖ Clic en IA realizado');

        try {
            targetPage = await Promise.race([
                newPagePromise,
                new Promise<Page | null>(resolve => setTimeout(() => {
                    resolve(cartaPage as Page); 
                }, 10000)) 
            ]);
        } catch (e) {
            console.warn("Error esperando nueva p√°gina, se usar√° la p√°gina de carta actual", e);
            targetPage = cartaPage; 
        }

        if (!targetPage) { 
             console.log("No se pudo determinar la p√°gina objetivo, usando cartaPage como fallback.");
             targetPage = cartaPage; 
        }

        await targetPage.bringToFront();
        await targetPage.waitForTimeout(12000); 

        const finalUrl = targetPage.url();
        console.log(`üìç URL despu√©s del clic en IA: ${finalUrl}`);

        if (finalUrl.includes('integrity.turnitin.com')) {
            console.log('‚úÖ Llegamos a la p√°gina del reporte de IA.');
            return targetPage;
        } else {
            pages = await browser.pages(); // Re-fetch pages
            const integrityPage = pages.find(p => p.url().includes('integrity.turnitin.com'));
            if (integrityPage) {
                console.log(`‚úÖ Encontrada p√°gina de integridad en segundo plano: ${integrityPage.url()}`);
                await integrityPage.bringToFront();
                await integrityPage.waitForTimeout(5000);
                return integrityPage;
            }
            throw new Error(`URL inesperada despu√©s del clic en IA: ${finalUrl}. Se esperaba "integrity.turnitin.com"`);
        }
    } finally {
        // Ensure rl is closed if it was created in this function scope
        if (rl) { // Check if rl was initialized
            // Removed: && !rl.closed
            rl.close();
        }
    }
}


async function detectAndConfirmDownload(projectDownloadPath: string): Promise<boolean> {
    console.log('\nüïµÔ∏è DETECTANDO Y CONFIRMANDO DESCARGA...');
    console.log('========================================');
    
    const downloadLocations = [
        projectDownloadPath,
        path.join(os.homedir(), 'Downloads'),
    ].filter(loc => fs.existsSync(loc));

    console.log('üìÅ Verificando en las siguientes ubicaciones:');
    downloadLocations.forEach(loc => console.log(`   - ${loc}`));

    const expectedFileBaseName = EXACT_JSON_DATA.workTitle.split('.')[0].toLowerCase();
    let downloadConfirmed = false;
    const maxAttempts = 4; 
    const attemptDelay = 7000; 

    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
        console.log(`\n--- Intento de detecci√≥n ${attempt} de ${maxAttempts} ---`);
        for (const location of downloadLocations) {
            if (!fs.existsSync(location)) continue; 
            const filesInLocation = fs.readdirSync(location);
            for (const file of filesInLocation) {
                const filePath = path.join(location, file);
                const fileNameLower = file.toLowerCase();

                if (!fileNameLower.endsWith('.pdf')) continue;

                try {
                    const stats = fs.statSync(filePath);
                    const isRecent = (Date.now() - stats.mtimeMs) < (15 * 60 * 1000); 

                    if (fileNameLower.includes(expectedFileBaseName) && isRecent) {
                        console.log(`üéâ ¬°DESCARGA CONFIRMADA!`);
                        console.log(`   Archivo: ${file}`);
                        console.log(`   Ubicaci√≥n: ${location}`);
                        console.log(`   Tama√±o: ${(stats.size / 1024).toFixed(2)} KB`);
                        console.log(`   Modificado: ${stats.mtime.toLocaleString()}`);

                        const safeOriginalFileName = file.replace(/[^a-zA-Z0-9_.-]/g, '_');
                        const finalFileName = `AI_Report_${EXACT_JSON_DATA.workTitle.split('.')[0]}_${new Date().toISOString().replace(/[:.]/g, '-')}_${safeOriginalFileName}`;
                        const destPath = path.join(projectDownloadPath, finalFileName);

                        if (path.resolve(filePath) !== path.resolve(destPath)) { 
                           if (fs.existsSync(destPath) && fs.statSync(destPath).size === stats.size) { 
                                console.log(`   ‚ÑπÔ∏è  Un archivo id√©ntico ya existe en temp-downloads: ${finalFileName}`);
                           } else {
                                fs.copyFileSync(filePath, destPath);
                                console.log(`   ‚úÖ COPIADO a temp-downloads como: ${finalFileName}`);
                           }
                        } else {
                            console.log(`   ‚ÑπÔ∏è  El archivo ya est√° en la carpeta de destino del proyecto (temp-downloads).`);
                        }
                        downloadConfirmed = true;
                        break; 
                    }
                } catch (statError: any) {
                    if (statError.code !== 'ENOENT') {
                        console.warn(`   ‚ö†Ô∏è No se pudo obtener info de ${file}: ${statError.message}`);
                    }
                }
            }
            if (downloadConfirmed) break; 
        }
        if (downloadConfirmed) break; 

        if (attempt < maxAttempts) {
            console.log(`   ...no se encontr√≥ el archivo a√∫n, esperando ${attemptDelay / 1000}s para el siguiente intento...`);
            await new Promise(resolve => setTimeout(resolve, attemptDelay));
        }
    }

    if (!downloadConfirmed) {
        console.log('\n‚ùå No se pudo confirmar la descarga del archivo PDF esperado despu√©s de varios intentos.');
        console.log('   Por favor, verifica manualmente las carpetas de descarga.');
    }
    return downloadConfirmed;
}

if (require.main === module) {
    fullyAutomatedAIDownload();
}
